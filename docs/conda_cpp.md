使用conda管理c++环境
====

# conda前夕
在没有使用conda管理c++包之前，我们是怎么来管理c++的包呢？这里主要考虑的是生产
环境下linux和mac开发环境，windows上管理请绕行。

## 系统级别 

- 系统级别的包管理在centos/rh系列系统上，通过yum管理
- debian系统通过apt-get 管理包
- macos上通过brew管理包

## 项目级包管理

系统级的包管理并不能满足生产换下c++环境的管理，因此出现多种环境管理的工具

- git submodule方式。可以按照git的提交引入依赖包，弱点是每次编译，都要对依赖重新
编译，对比较多的依赖，很耗费时间。并且在循环依赖上会有比较多的麻烦。
  
- bazel/blade bazel是google开发的编译工具，blade是腾讯开发的编译工具，这两款
工具都集成依赖包管理的功能，但是这两款工具有强绑定的属性，即使用方也必须使用他们，才能顺利
  的引入包，并且语法稍微晦涩一些，学习成本有些搞，blade还不支持下载功能，依赖包的管理还存在
  较多人工适配的工作。虽然依赖包有缓存功能，但是绑定的属性太强，项目接入需要比较多的适配。
  
- conan conan 是杰娃公司开源的二进制管理工具，conan与cmake结合紧密，conan分为客户端和服务端
可以按照包的版本管理依赖，并且支持循环依赖。唯一的弱点是在引入生成包时，需要较多的cmake配置和python3
  脚本的配置。并且二进制服务器是要收费的。
  
- cmake cmake是完全开源的，cmake也支持包管理的引入，cmake到没有前绑定的属性，但是随着cmake的
的不断升级，cmake引入依赖的方式目前也是千奇百怪。cmake最大的优势是支持安装unix install方式安装
  包，对于依赖的包，依然需要每次都编译。
  
在conda之前，我自己还开发过一个工具，carbin，管理c++的依赖，支持二进制的下载，生成，上传，只要的
特点是：
1. 支持二进制按照版本管理包
2. 支持循环依赖
3. 使用简洁，只有yaml格式配置文件和二进制程序。
这些特点也都是conda的特点，但是conda比carbin最大的优势，社区，免费社区的支持。
   社区已经把大多数开源软件，按照不同版本，生成二进制，存放到conda公共仓库。从产品
   形态上更加简洁，他只好做包管理这一件事情，并支持conda 构建，上传个人包。发自按这个
   工具如果至宝，也就废弃了carbin，使用conda管理c++环境。
   
转移到conda上的另外一个原因，算法的框架和软件都是通过conda管理，这些框架大多数都是
python开发，统一c++和python环境，在开发过程中也遍历很多。
   
# conda  管理c++包

## 编译器依赖

在没有使用conda之前，凡是项目对编译器有依赖是一件很麻烦的事情，特别是c++11以上标准，
因标准库在gcc5.0之后，c++的标准库重新实现了， 比如std::string类，实际是std::__cxx11::basic_string,
导致操作系统的gcc升级后，很多系统库都无法使用。在生产环境中升级gcc也是很繁琐的事情。特别是混布
的系统。

有了conda管理之后，所有的问题也都迎刃而解。

gcc 和 g++ 通常使用conda-forge 作为源，通常，c17可以用 8.5版本，g++对应但这里要注意的是
安装g++，对应的软件名字是gxx。另外一点需要注意，glibc需要额外安装 sysroot_linux-64，参见上一节的环境配置文件。




  